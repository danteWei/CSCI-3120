Q1:
	One difficulty is that when doing something like access control, file management, and password, etc. since even OS cannot modify itself, those things will have to be stored in somewhere in memory that is unprotected and can be accessed by unauthorized users. In Microkernel architecture, for example, since this kind of OS only the core functionality is run in kernel mode and all others including file system is run as separate user space and only change into kernel mode when necessary, so this type of OS is less affected than other type of architectures. If the architecture of the system is simple architecture, since the entire OS is run in Kernel mode, that means nearly nothing is protected if no one is allowed to modify the OS.

	Another one is when trigger an interrupt, since we cannot modify the OS, that means the triggered interrupt cannot be run in Kernel mode, and thus anyone can modify interrupt and the OS may no longer be in control.


Q2:
	Consider the backing-store driver and the CPU scheduler. Usually the driver is placed in the layer above the layer that contains the CPU scheduler, this is because when the driver is waiting for I/O, the scheduler has to reschedule the CPU. But in the process of rescheduling, it may require information of all processes so that the scheduler can optimize the CPU usage. However, this requires the scheduler to send data to memory and retrieve data from memory, and this cannot be done if the backing-store driver is above the CPU scheduler.


Q3:
	Suppose all those processes are in the ready queue, let Xi be the timer that the ith process needed, we first set the timer for the system be the greatest common divisor of (X1, X2, …, Xn), namely X0, then set the system timer be X0, we also stores the results of Xi/X0 in an array (A[n]), each of which correspond to the ith process. As the processes are running, when the alarm is trigger, decrement every element in A[n] and check if there is any element is equal to 0, if an element, let’s say, A[m], is 0, then trigger the alarm function of process Xm. If a new process is added, then recompute X0 and update A[n] and keep going.

Q4:
	Consider the following:
		
	Server: socket() —> bind() —> listen() —> accept() —> send()/receive(), etc —> close()

	If we consider a web server as a CPU, then since a process is a program in execution (Operating System Concepts), we can treat socket as an equivalent term of process in OS (answer to (a)). And since socket() creates a socket and bind() function binds a name to the socket and thus is a process of packaging a newly-created socket, so bind() constitutes the processing state of the process similar to register contents for an OS process (answer to (b)). According to the flow chart above, socket() is equivalent to New state since the function creates a new socket, listen() is equivalent to ready state because in this process, the socket is ready to be send. Once the server accepts a connection, the connection is established and the socket is processed, so functions like read(), write(), send(), etc. are equivalent to the running state, and functions like receive(), etc are blocked state since they all requires something from the client side before they continue. And finally close() closes a connection, so close() is equivalent to the exit state.
